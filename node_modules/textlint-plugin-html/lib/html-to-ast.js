// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.parse = parse;

var _hast = require("hast");

var _hast2 = _interopRequireDefault(_hast);

var _traverse = require("traverse");

var _traverse2 = _interopRequireDefault(_traverse);

var _structuredSource = require("structured-source");

var _structuredSource2 = _interopRequireDefault(_structuredSource);

var _mapping = require("./mapping");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Remove undocumented properties on TxtNode from node
 * @param {TxtNode} node already has loc,range
 */
function removeUnusedProperties(node) {
    if ((typeof node === "undefined" ? "undefined" : _typeof(node)) !== "object") {
        return;
    }
    ["position"].forEach(function (key) {
        if (node.hasOwnProperty(key)) {
            delete node[key];
        }
    });
}
function mapNodeType(node, parent) {
    if (parent) {
        var parentNode = parent.parent.node;
        if (parentNode.tagName === "script" || parentNode.tagName === "style") {
            return "CodeBlock";
        }
    }
    if (node.tagName && node.type === "element") {
        var mappedType = _mapping.tagNameToType[node.tagName];
        if (mappedType) {
            // p => Paragraph...
            return mappedType;
        } else {
            // other element is "Html"
            return "Html";
        }
    } else {
        // text => Str
        return _mapping.nodeTypes[node.type];
    }
}
function parse(html) {
    var ast = _hast2.default.parse(html);
    var src = new _structuredSource2.default(html);
    var tr = (0, _traverse2.default)(ast);
    tr.forEach(function (node) {
        if (this.notLeaf) {
            // avoid conflict <input type="text" />
            // AST node has type and position
            if (node.type && node.position) {
                // case: element => Html or ...
                node.type = mapNodeType(node, this.parent);
            } else if (node.type === "root") {
                // FIXME: workaround, should fix hast
                node.type = _mapping.nodeTypes[node.type];
                var position = src.rangeToLocation([0, html.length]);
                // reverse adjust
                node.position = {
                    start: { line: position.start.line, column: position.start.column + 1 },
                    end: { line: position.end.line, column: position.end.column + 1 }
                };
            }
            // Unknown type
            if (typeof node.type === "undefined") {
                node.type = "UNKNOWN";
            }
            // map `range`, `loc` and `raw` to node
            if (_typeof(node.position) === "object") {
                var _position = node.position;
                // TxtNode's line start with 1
                // TxtNode's column start with 0
                var positionCompensated = {
                    start: { line: _position.start.line, column: _position.start.column - 1 },
                    end: { line: _position.end.line, column: _position.end.column - 1 }
                };
                var range = src.locationToRange(positionCompensated);
                node.loc = positionCompensated;
                node.range = range;
                node.raw = html.slice(range[0], range[1]);
            }
            // map `url` to Link node
            if (node.type === "Link" && typeof node.properties.href !== "undefined") {
                node.url = node.properties.href;
            }
        }
        removeUnusedProperties(node);
    });
    return ast;
}
//# sourceMappingURL=html-to-ast.js.map